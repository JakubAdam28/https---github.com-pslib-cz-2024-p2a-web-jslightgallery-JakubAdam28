import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as Styled from '../styles/styled';
import { TIMINGFUNC_MAP } from '../utils/functions';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import useEffectOnce from '../utils/useEffectOnce';
const TimerBar = ({ interval, initStartTime, forcePause }) => {
    const [style, setStyle] = useState();
    useEffect(() => {
        if (forcePause)
            return;
        let frameId;
        let start = initStartTime;
        const step = time => {
            const timestamp = performance.timeOrigin + time;
            if (!start)
                start = timestamp;
            const diff = timestamp - start;
            const percentage = Math.min(diff / interval, 1);
            setStyle({ left: `${percentage * 100}%`, width: `${100 - percentage * 100}%` });
            if (diff <= interval) {
                frameId = requestAnimationFrame(step);
            }
        };
        frameId = requestAnimationFrame(step);
        return () => cancelAnimationFrame(frameId);
    }, [interval, initStartTime, forcePause]);
    return _jsx(Styled.TimerBar, { style: style });
};
const ImageWrapper = ({ item }) => {
    return item.link ? (_jsx(Styled.ImageWrapperA, Object.assign({ theme: { backgroundColor: item.backgroundColor }, href: item.link, target: item.newTab ? '_blank' : undefined, rel: "noopener noreferrer", draggable: false }, { children: _jsx(Styled.Image, { theme: { objectFit: item.objectFit }, src: item.image, draggable: false }) }))) : (_jsx(Styled.ImageWrapperDiv, Object.assign({ theme: { backgroundColor: item.backgroundColor } }, { children: _jsx(Styled.Image, { theme: { objectFit: item.objectFit }, src: item.image, draggable: false }) })));
};
const JSSwiper = ({ items, prevButton, nextButton, stateButton, duration = 200, interval = 0, onChangeItem: handleChangeItem = () => { }, onChangeState: handleChangeState = () => { }, width, height, startEffect, }) => {
    var _a, _b, _c;
    if (!items.length)
        return null;
    if (items.length === 1)
        items = Array(2).fill(items[0]).map((item, i) => (Object.assign(Object.assign({}, item), { order: item.order + i })));
    const initialStyle = { transform: `translate3d(0%, 0, 0)` };
    const mainEl = useRef(null);
    const mainWidth = useMemo(() => { var _a; return ((_a = mainEl.current) === null || _a === void 0 ? void 0 : _a.clientWidth) || 0; }, [(_a = mainEl.current) === null || _a === void 0 ? void 0 : _a.clientWidth]);
    const swipeSize = useMemo(() => { var _a, _b; return (_b = (((_a = mainEl.current) === null || _a === void 0 ? void 0 : _a.clientWidth) || 0) / 4) !== null && _b !== void 0 ? _b : 100; }, [(_b = mainEl.current) === null || _b === void 0 ? void 0 : _b.clientWidth]);
    const [item, setItem] = useState({ visible: items[0] });
    const [style, setStyle] = useState(initialStyle);
    const [timerId, setTimerId] = useState();
    const [startTime, setStartTime] = useState(new Date().getTime());
    const [diff, setDiff] = useState();
    const [timerBarPause, setTimerBarPause] = useState(false);
    const [touch, setTouch] = useState();
    useEffect(() => setButtonEvent(prevButton, handlePrev), [item.visible, prevButton]);
    useEffect(() => setButtonEvent(nextButton, handleNext), [item.visible, nextButton]);
    useEffect(() => {
        const state = stateButton === null || stateButton === void 0 ? void 0 : stateButton.current;
        if (!state)
            return;
        const handleClick = () => (timerId ? handlePause() : handlePlay());
        state.addEventListener('click', handleClick);
        return () => state.removeEventListener('click', handleClick);
    }, [timerId, stateButton, startTime, diff]);
    useEffect(() => {
        if (touch) {
            setItem(item => ({ visible: item.prev ? item.prev : item.next ? item.next : item.visible }));
            setTouch(undefined);
            return;
        }
        if (item.prev) {
            setStyle({ transform: `translate3d(0%, 0, 0)`, transition: `transform ${duration}ms ease` });
        }
        else if (item.next) {
            setStyle({ transform: `translate3d(-100%, 0, 0)`, transition: `transform ${duration}ms ease` });
        }
        else {
            setStyle(initialStyle);
        }
    }, [item]);
    useEffect(() => {
        if (item.prev) {
            handleChangeState('play');
            handleChangeItem(item.prev);
        }
        if (item.next) {
            handleChangeState('play');
            handleChangeItem(item.next);
        }
    }, [item.prev, item.next]);
    const setButtonEvent = (ref, handler) => {
        const el = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!el)
            return;
        const handlerMiddleware = () => {
            setStartTime(new Date().getTime());
            handleAutoPlay();
            handler();
        };
        el.addEventListener('click', handlerMiddleware);
        return () => el.removeEventListener('click', handlerMiddleware);
    };
    let effect;
    if (!startEffect)
        effect = useEffect;
    else if (startEffect === 'useEffectOnce')
        effect = useEffectOnce;
    else
        effect = startEffect;
    effect(() => {
        handlePlay();
    }, []);
    useEffect(() => () => {
        clearTimeout(timerId);
        clearInterval(timerId);
    }, [timerId]);
    const getIndex = (item) => items.findIndex(v => v.order === item.order);
    const getNeighbor = (arg) => {
        const index = typeof arg !== 'number' ? getIndex(arg) : arg;
        const item = typeof arg !== 'number' ? arg : items[arg];
        const prevIndex = index === 0 ? items.length - 1 : index - 1;
        const prev = items[prevIndex];
        const nextIndex = index === items.length - 1 ? 0 : index + 1;
        const next = items[nextIndex];
        const visible = item;
        return { prev, visible, next };
    };
    const handlePrev = () => handleBoth('prev');
    const handleNext = () => handleBoth('next');
    const handleBoth = (type) => {
        setStartTime(new Date().getTime());
        setStyle(type === 'next' ? initialStyle : { transform: `translate3d(-100%, 0, 0)` });
        setItem(item => {
            var _a;
            return (Object.assign(Object.assign({}, getNeighbor((_a = item[type]) !== null && _a !== void 0 ? _a : item.visible)), { [type === 'prev' ? 'next' : 'prev']: undefined }));
        });
    };
    const handleAutoPlay = () => !!interval && interval > 0 && setTimerId(setInterval(handleNext, interval));
    const handleTimeoutInterval = (timeout_interval, interval) => {
        if (!interval || interval < 0)
            return;
        setTimerId(setTimeout(() => {
            handleNext();
            setTimerId(setInterval(handleNext, interval));
        }, timeout_interval));
    };
    const handlePlay = () => {
        if (!interval || interval < 0)
            return;
        const continueTime = interval - (diff !== null && diff !== void 0 ? diff : 0);
        setStartTime(new Date().getTime() + continueTime - interval);
        setTimerBarPause(false);
        handleChangeState('play');
        handleTimeoutInterval(continueTime, interval);
    };
    const handlePause = () => {
        const diff = new Date().getTime() - startTime;
        setDiff(diff);
        setTimerBarPause(true);
        handleChangeState('pause');
        clearInterval(timerId);
        setTimerId(undefined);
    };
    const handleTransitionEnd = () => {
        setItem(item => ({ visible: item.prev ? item.prev : item.next ? item.next : item.visible }));
    };
    /** For mobile device */
    useEffect(() => {
        if (!mainEl.current)
            return;
        const handleTouchMove = (e) => {
            e.preventDefault();
        };
        mainEl.current.addEventListener('touchmove', handleTouchMove);
        return () => { var _a; return (_a = mainEl.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', handleTouchMove); };
    }, [mainEl]);
    const handleTouchStart = (e) => {
        if (touch)
            return;
        handlePause();
        const posX = e.touches.item(0).clientX;
        setTouch({ initX: posX });
    };
    const handleTouchMove = useCallback((e) => {
        if (!touch)
            return;
        const posX = e.touches.item(0).clientX;
        const state = posX - touch.initX < 0 ? 'forward' : posX === touch.initX ? 'same' : 'backward';
        let prev, next;
        let additionalTransform = '';
        if (state === 'forward') {
            next = getNeighbor(item.visible).next;
        }
        else if (state === 'backward') {
            prev = getNeighbor(item.visible).prev;
            additionalTransform = 'translate3d(-100%, 0, 0) ';
        }
        setTouch(touch => (touch ? Object.assign(Object.assign({}, touch), { lastX: posX, style: { transform: additionalTransform + `translate3d(${posX - touch.initX}px, 0, 0)` }, prev, next }) : undefined));
    }, [touch]);
    const handleTouchEnd = useCallback((e) => {
        if (touch === null || touch === void 0 ? void 0 : touch.lastX) {
            const timingFunc = TIMINGFUNC_MAP['ease'];
            let start;
            const initX = touch.lastX - touch.initX;
            const isChange = Math.abs(initX) > swipeSize;
            const isNext = Math.sign(initX) < 0;
            const toX = isChange ? Math.sign(initX) * mainWidth : 0;
            const step = time => {
                if (!start)
                    start = time;
                const diff = time - start;
                const percentage = Math.min(diff / duration, 1);
                setTouch(touch => {
                    if (touch) {
                        const defaultTransform = `translate3d(${(toX - initX) * timingFunc(percentage) + initX}px, 0, 0) `;
                        const additionalTransform = `translate3d(-100%, 0, 0) `;
                        const transform = touch.prev ? additionalTransform + defaultTransform : defaultTransform;
                        return Object.assign(Object.assign({}, touch), { style: { transform } });
                    }
                    else {
                        return undefined;
                    }
                });
                if (diff <= duration) {
                    requestAnimationFrame(step);
                }
                else {
                    if (isChange) {
                        if (isNext)
                            handleNext();
                        else
                            handlePrev();
                        if (!!interval && interval > 0)
                            setTimerId(setInterval(handleNext, interval));
                    }
                    else {
                        handlePlay();
                    }
                }
            };
            requestAnimationFrame(step);
        }
        else {
            setTouch(undefined);
            handlePlay();
        }
    }, [touch]);
    return (_jsxs(Styled.Container, Object.assign({ ref: mainEl, style: { width, height } }, { children: [!!interval && _jsx(TimerBar, { interval: interval - duration - 200, initStartTime: startTime, forcePause: timerBarPause }), _jsxs(Styled.ImagesWrapper, Object.assign({ style: (_c = touch === null || touch === void 0 ? void 0 : touch.style) !== null && _c !== void 0 ? _c : style, onTransitionEnd: handleTransitionEnd, 
                /** For mobile device */
                onContextMenu: e => e.preventDefault(), onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd }, { children: [!item.prev && !!(touch === null || touch === void 0 ? void 0 : touch.prev) && _jsx(ImageWrapper, { item: touch.prev }, touch.prev.order), !!item.prev && _jsx(ImageWrapper, { item: item.prev }, item.prev.order), _jsx(ImageWrapper, { item: item.visible }, item.visible.order), !!item.next && _jsx(ImageWrapper, { item: item.next }, item.next.order), !item.next && !!(touch === null || touch === void 0 ? void 0 : touch.next) && _jsx(ImageWrapper, { item: touch.next }, touch.next.order)] }))] })));
};
export default JSSwiper;
